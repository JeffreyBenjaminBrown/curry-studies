* a simpler model for queries
** Querying pairs of ints
type P = (Int,Int)
PQuery =  PImg [P]  |  PHas Int
  .    |  PAnd [PQuery]  |  POr [PQuery]
  .    |  PNot PQuery  |  PVar String  |  PAnonVar Int
** Querying trees
data T = T Int [T]
TQuery: TImg T
  .  |  THasMember TQuery  |  THas TQuery  |  THasAt TQuery
  .  |  TAnd [TQuery]  |  TOr [TQuery]
  .  |  TNot TQuery  |  TVariety Variety  |  TVar String  | TAnonVar Int
* to do
** features
*** query the db
**** query types
Query : QImg ImgOfExpr  |  QRel [Query] Query
  .  |  QHasMember Query  |  QHas Query  |  QHasAt Query
  .  |  QAnd [Query]  |  QOr [Query]
  .  |  QNot Query  |  QVariety Variety  |  QVar String  | QAnonVar Int
**** "runnability" and datalog-style conditioning
"Runnable" means "sometimes valid". A user can only run valid Queries, but a Query can be valid even with invalid subqueries.
QImg        : runnable. Vvalid.
QRel        : runnable. Vvalid <=> has a valid subQuery (maybe the template).
QHas*       : runnable. Vvalid <=> has a valid Query.
QAnd        : runnable. Vvalid <=> has a valid Query.
QOr         : runnable. Vvalid <=> has only valid Queries.
QNot, QVariety, \*Var  :  not runnable, not valid.
**** TODO algorithms (only exist for "runnable" Queries)
**** a complex query
(x,y) where "?x #is blue ##because refraction"
          & "?x #eats ?y"
          & x=("_ #of _" | Par)
          & y=( not( has "bird" ) )
*** represent rules in the db
*** Hash
*** edit a db
** minor
*** (awaiting response) Tests.curry:-- call `broken` fron the REPL?
  https://stackoverflow.com/questions/53547365/the-pakcs-repl-consider-something-undefined-but-the-module-defining-it-is-loade
*** Index.exprImgKey'default x = Just x -- TODO : Why the warning?
*** (awaiting response) add Util.sort to the List module
  https://mail.google.com/mail/u/0/#sent/KtbxLvHkVTXWJFRfxzwlKdBtLNPMLtGMcL
** change architecture
*** force full evaluation of index immediately
*** use ordinary hard-disk files rather than Rslt.Files
* some Curry functions I might need
** use &> instead of guards
These seem to be equivalent:

somethingThatHoldsAt :: Index -> Int -> Addr -> Addr
somethingThatHoldsAt i pos a0
  | Just s =:= positionsHeldBy i a0
    & fElem (RoleMember pos, a) (setRBT2list s)
  = a where a,s free

aRelUsingTemplate    :: Index -> Addr -> Addr
aRelUsingTemplate i a0
  | Just s =:= positionsHeldBy i a0
    & fElem (RoleTplt, a) (setRBT2list s)
  = a where a,s free
** Hex-formatting a number
showInt 'x' Nothing (Just 1) (Just 1) 31
* pitfall & solved, I think
** ? conflicting definitions, (supposedly) in standard library
*** It happens if I import two libraries, unqualified, that define the same name
*** example
**** if I add this line to All.curry:
 import List as M
**** then I get these errors
 /home/jeff/logic/curry/install/pakcs-2.0.2/lib/.curry/List.icurry, line 6.1: Error:
     Multiple exports of name `delete' at:
       line 6.1
       line 4.1

 /home/jeff/logic/curry/install/pakcs-2.0.2/lib/.curry/List.icurry, line 49.1: Error:
     Multiple exports of name `sortBy' at:
       line 49.1
       line 17.1
